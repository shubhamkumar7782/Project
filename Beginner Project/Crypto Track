

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title CryptoTrack
 * @dev A smart contract for tracking cryptocurrency portfolios on-chain
 * @author Crypto Track Team
 */
contract Project {
    // Struct to represent a cryptocurrency holding
    struct CryptoHolding {
        string symbol;
        uint256 amount;
        uint256 purchasePrice;
        uint256 timestamp;
        bool active;
    }
    
    // Mapping from user address to their portfolio holdings
    mapping(address => CryptoHolding[]) private userPortfolios;
    
    // Mapping to track total number of holdings per user
    mapping(address => uint256) private userHoldingCount;
    
    // Events
    event HoldingAdded(address indexed user, string symbol, uint256 amount, uint256 price);
    event HoldingUpdated(address indexed user, uint256 holdingIndex, uint256 newAmount);
    event HoldingRemoved(address indexed user, uint256 holdingIndex);
    
    // Modifiers
    modifier validHoldingIndex(uint256 _index) {
        require(_index < userPortfolios[msg.sender].length, "Invalid holding index");
        require(userPortfolios[msg.sender][_index].active, "Holding is not active");
        _;
    }
    
    /**
     * @dev Core Function 1: Add a new cryptocurrency holding to user's portfolio
     * @param _symbol The cryptocurrency symbol (e.g., "BTC", "ETH")
     * @param _amount The amount of cryptocurrency held
     * @param _purchasePrice The price at which the cryptocurrency was purchased (in wei)
     */
    function addHolding(
        string memory _symbol, 
        uint256 _amount, 
        uint256 _purchasePrice
    ) external {
        require(bytes(_symbol).length > 0, "Symbol cannot be empty");
        require(_amount > 0, "Amount must be greater than zero");
        require(_purchasePrice > 0, "Purchase price must be greater than zero");
        
        CryptoHolding memory newHolding = CryptoHolding({
            symbol: _symbol,
            amount: _amount,
            purchasePrice: _purchasePrice,
            timestamp: block.timestamp,
            active: true
        });
        
        userPortfolios[msg.sender].push(newHolding);
        userHoldingCount[msg.sender]++;
        
        emit HoldingAdded(msg.sender, _symbol, _amount, _purchasePrice);
    }
    
    /**
     * @dev Core Function 2: Update the amount of an existing cryptocurrency holding
     * @param _holdingIndex The index of the holding to update
     * @param _newAmount The new amount of cryptocurrency held
     */
    function updateHoldingAmount(
        uint256 _holdingIndex, 
        uint256 _newAmount
    ) external validHoldingIndex(_holdingIndex) {
        require(_newAmount > 0, "New amount must be greater than zero");
        
        userPortfolios[msg.sender][_holdingIndex].amount = _newAmount;
        
        emit HoldingUpdated(msg.sender, _holdingIndex, _newAmount);
    }
    
    /**
     * @dev Core Function 3: Get user's complete portfolio information
     * @return holdings Array of all active cryptocurrency holdings for the user
     * @return totalHoldings Total number of active holdings
     */
    function getPortfolio() external view returns (
        CryptoHolding[] memory holdings, 
        uint256 totalHoldings
    ) {
        uint256 activeCount = 0;
        
        // Count active holdings
        for (uint256 i = 0; i < userPortfolios[msg.sender].length; i++) {
            if (userPortfolios[msg.sender][i].active) {
                activeCount++;
            }
        }
        
        // Create array of active holdings
        CryptoHolding[] memory activeHoldings = new CryptoHolding[](activeCount);
        uint256 currentIndex = 0;
        
        for (uint256 i = 0; i < userPortfolios[msg.sender].length; i++) {
            if (userPortfolios[msg.sender][i].active) {
                activeHoldings[currentIndex] = userPortfolios[msg.sender][i];
                currentIndex++;
            }
        }
        
        return (activeHoldings, activeCount);
    }
    
    /**
     * @dev Remove a cryptocurrency holding from portfolio (mark as inactive)
     * @param _holdingIndex The index of the holding to remove
     */
    function removeHolding(uint256 _holdingIndex) external validHoldingIndex(_holdingIndex) {
        userPortfolios[msg.sender][_holdingIndex].active = false;
        userHoldingCount[msg.sender]--;
        
        emit HoldingRemoved(msg.sender, _holdingIndex);
    }
    
    /**
     * @dev Get specific holding information by index
     * @param _holdingIndex The index of the holding to retrieve
     * @return holding The cryptocurrency holding information
     */
    function getHolding(uint256 _holdingIndex) 
        external 
        view 
        validHoldingIndex(_holdingIndex) 
        returns (CryptoHolding memory holding) 
    {
        return userPortfolios[msg.sender][_holdingIndex];
    }
    
    /**
     * @dev Get total number of active holdings for the user
     * @return count Total number of active holdings
     */
    function getTotalHoldingsCount() external view returns (uint256 count) {
        return userHoldingCount[msg.sender];
    }
    
    /**
     * @dev Calculate total portfolio value based on current prices
     * @param _currentPrices Array of current prices corresponding to user's holdings
     * @return totalValue Total portfolio value in wei
     */
    function calculatePortfolioValue(uint256[] memory _currentPrices) 
        external 
        view 
        returns (uint256 totalValue) 
    {
        require(_currentPrices.length == userHoldingCount[msg.sender], "Price array length mismatch");
        
        uint256 priceIndex = 0;
        totalValue = 0;
        
        for (uint256 i = 0; i < userPortfolios[msg.sender].length; i++) {
            if (userPortfolios[msg.sender][i].active) {
                totalValue += userPortfolios[msg.sender][i].amount * _currentPrices[priceIndex];
                priceIndex++;
            }
        }
        
        return totalValue;
    }
}
